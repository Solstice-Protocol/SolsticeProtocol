#!/usr/bin/env node
/**
 * Export verification keys from snarkjs to Rust format for Solana program
 * This script reads the verification keys generated by snarkjs and converts them
 * to a format that can be used in the Rust smart contract
 */

const fs = require('fs');
const path = require('path');

const BUILD_DIR = path.join(__dirname, '..', 'build');
const OUTPUT_DIR = path.join(__dirname, '..', '..', 'contracts', 'programs', 'contracts', 'src');

// Circuit names
const CIRCUITS = ['age_proof', 'nationality_proof', 'uniqueness_proof'];

/**
 * Convert verification key JSON to Rust byte array format
 */
function vkeyToRustBytes(vkey) {
    // Extract the key components we need for Groth16 verification
    // Based on: https://docs.sui.io/guides/developer/cryptography/groth16
    
    const components = [];
    
    // vk_gamma_abc_g1_bytes
    if (vkey.vk_gamma_abc_g1) {
        for (const point of vkey.vk_gamma_abc_g1) {
            components.push(point);
        }
    }
    
    // alpha_g1_beta_g2_bytes
    if (vkey.vk_alpha_1 && vkey.vk_beta_2) {
        components.push(vkey.vk_alpha_1);
        components.push(vkey.vk_beta_2);
    }
    
    // gamma_g2_neg_pc_bytes
    if (vkey.vk_gamma_2) {
        components.push(vkey.vk_gamma_2);
    }
    
    // delta_g2_neg_pc_bytes
    if (vkey.vk_delta_2) {
        components.push(vkey.vk_delta_2);
    }
    
    // Serialize to hex string
    const serialized = JSON.stringify(components);
    const hex = Buffer.from(serialized).toString('hex');
    
    // Convert to Rust byte array format
    const bytes = hex.match(/.{1,2}/g);
    return bytes.map(b => `0x${b}`).join(', ');
}

/**
 * Generate Rust constant declaration for verification key
 */
function generateRustConst(circuitName, vkeyBytes) {
    const constName = circuitName.toUpperCase().replace('_PROOF', '_VK');
    
    return `    /// ${circuitName} verification key (BN254 curve)
    pub const ${constName}: &'static [u8] = &[
        ${vkeyBytes}
    ];`;
}

/**
 * Main export function
 */
async function exportVerificationKeys() {
    console.log('ğŸ”‘ Exporting verification keys...\n');
    
    const rustConsts = [];
    
    for (const circuit of CIRCUITS) {
        const vkeyPath = path.join(BUILD_DIR, `${circuit}_verification_key.json`);
        
        if (!fs.existsSync(vkeyPath)) {
            console.warn(`âš ï¸  Warning: ${circuit}_verification_key.json not found`);
            console.warn(`   Run 'npm run setup:${circuit.split('_')[0]}' first\n`);
            continue;
        }
        
        console.log(`ğŸ“„ Processing ${circuit}...`);
        
        // Read verification key
        const vkey = JSON.parse(fs.readFileSync(vkeyPath, 'utf8'));
        
        // Convert to Rust bytes
        const vkeyBytes = vkeyToRustBytes(vkey);
        
        // Generate Rust constant
        const rustConst = generateRustConst(circuit, vkeyBytes);
        rustConsts.push(rustConst);
        
        console.log(`âœ… Exported ${circuit} verification key`);
        console.log(`   Size: ${vkeyBytes.length} bytes\n`);
    }
    
    if (rustConsts.length === 0) {
        console.error('âŒ No verification keys found!');
        console.error('   Run circuit compilation and setup first:');
        console.error('   npm run compile:all && npm run setup:all\n');
        process.exit(1);
    }
    
    // Generate the Rust file content
    const rustContent = `// Auto-generated verification keys from circuits
// DO NOT EDIT MANUALLY - Generated by circuits/scripts/export_verification_keys.js

${rustConsts.join('\n\n')}
`;
    
    // Write to verification_keys.rs
    const outputPath = path.join(OUTPUT_DIR, 'verification_keys.rs');
    fs.writeFileSync(outputPath, rustContent);
    
    console.log('âœ… Verification keys exported successfully!');
    console.log(`ğŸ“ Output: ${outputPath}\n`);
    
    console.log('ğŸ“‹ Next steps:');
    console.log('   1. Update groth16_verifier.rs to use these constants');
    console.log('   2. Rebuild the Solana program: cd contracts && anchor build');
    console.log('   3. Deploy to devnet: anchor deploy --provider.cluster devnet\n');
}

// Run the export
exportVerificationKeys().catch(err => {
    console.error('âŒ Error:', err);
    process.exit(1);
});
